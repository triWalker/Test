/*
 * Copyright 2016 Vassar College
 * All rights reserverd.
 */
package parser;


import errors.LexicalError;
import errors.SemanticError;
import errors.SymbolTableError;
import errors.SyntaxError;

import grammar.SemanticAction;
import semanticActions.SemanticActions;

import grammar.GrammarSymbol;
import grammar.NonTerminal;
import lex.Token;
import lex.TokenType;
import lex.Tokenizer;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import java.util.Stack;

import symbolTable.*;


public class Parser {
	private static final int ERROR = 999;

	private ParseTable parsetable = new ParseTable();
	private RHSTable rhsTable = new RHSTable();

	private Tokenizer tokenizer;

	private SemanticActions semActs;

	private Token token;
	private Token savedToken; //will help continue parsing after error. Will be token that caused error previously
	private Token lastToken; //token to be used in the execution of a semantic action
	private Stack stack = new Stack();
	private boolean dump = true;
	private boolean errBool = false; //will be switched to true if error occurs

	public Parser(String filename) throws IOException, LexicalError, SymbolTableError {
		this(new File(filename));
	}

	public Parser(File file) throws IOException, LexicalError, SymbolTableError {
		tokenizer = new Tokenizer(file);
		semActs = new SemanticActions(tokenizer);
	}

	public void parse() throws SyntaxError, LexicalError, SemanticError, SymbolTableError, FileNotFoundException {
		// TODO Write a parser.
		token = tokenizer.getNextToken();

		savedToken = new Token();
		savedToken.setValue("NoError"); // Will say no error as long as error is not currently being worked around

		lastToken = new Token();

		// Start with "goal" on top of the stack
		stack.push(TokenType.ENDOFFILE);
		stack.push(NonTerminal.Goal);

		while (!stack.empty()) {

			GrammarSymbol symbol = (GrammarSymbol) stack.pop();

			if(symbol.isToken())
			{

				TokenType expectedType = (TokenType) symbol;
				System.out.println("" + expectedType +" and " + token.getType());
				//Check if current token's type matches the expected type
				if(expectedType.equals(token.getType()))
				{
					//Before moving on to next token, save the current token's values to lastToken, which will be used
					//later, if a semantic action is executed
					lastToken.setValue(token.getValue());
					lastToken.setType(token.getType());
					System.out.println("Matched Tokens");
					token = tokenizer.getNextToken();
					//System.out.println("New token is " + token);
				}
				else
				{   //Current token type does not match the expected type coming off the stack
					throw SyntaxError.BadToken(expectedType, token.getType(), tokenizer.getLineNumber());
				}
			}
			else if (symbol.isNonTerminal()) {
				int nextMove = parsetable.getEntry(token.getType(), (NonTerminal) symbol);
				if (nextMove == ERROR) {
					//An error would occur if next move was made using the current token
					errBool = true;

					if (token.getType().equals(TokenType.END)) {
						//Unexpected End Case
						throw SyntaxError.UnexpectedEnd(tokenizer.getLineNumber());
					}
					else if(symbol.equals(NonTerminal.statement_list_tail) || symbol.equals(NonTerminal.parameter_list_tail))
					{//These nonterminals have ";" in their first sets
						//Missing Semicolon Case
						throw SyntaxError.MissingSemicolon(tokenizer.getLineNumber());
					}
					else {
						//Must be a bad token
						throw SyntaxError.BadToken(token.getType(), tokenizer.getLineNumber(), token.getValue());
					}
				} else {
					//Next move is successful
					pushSymbols(nextMove);
				}
			} else { //Symbol must be an action

				//Execute the action
				SemanticAction action = (SemanticAction) symbol;
				System.out.println("Current Action is " + symbol);
				semActs.execute(action.getIndex(), lastToken);
			}
		}
		System.out.println("End of Parse.");
	}

	public void dumpstack() {
		if (dump) {
			System.out.println("Contents of stack are " + stack.toString());
		}
	}

	public void pushSymbols(int move) {
		if (move < 0) //Negative number means empty string
		{
			//do nothing, symbol will be popped, and parse will continue
		}
		else {
			//Get the new symbols generated by rhe grammar rule
			GrammarSymbol[] symbols = rhsTable.getRule(move);
			//Push symbols onto stack in reverse
			for (int index = symbols.length - 1; index >= 0; index--) {
				stack.push(symbols[index]);
			}
		}
	}

	public SymbolTableEntry lookup(String element)
	{
		return semActs.lookup(element);
	}

	public boolean error() {
		//Will return true if an error has occurred
		return errBool;
	}

}